#include <EEPROM.h>
#include "keyMemory.h"
#include "ButtonHandler.h"
#include <Wiegand.h>


/*
TODO:
- enable longpress to add new passcode
- enable super long press to clear all passcodes?
- passcode to be saved to eeprom 
  - note, max 10000 write/erase cycles.  unlmimted read
  - use sparingly
- order RFID tags
- order relay switch
- methods for entering and exiting settings mode ... so that after a code is enetered, settings mode is exited


*/



//////////////////////////////////////////////////////////////
/////////////////////////// DEFINITIONS //////////////////////

// Input Button 1 - for setting the passcode
#define PIN_SETTINGS 5

// max code size
#define MAXCODESIZE 8
#define MAXSAVEDCODES 

// LEDS 
#define REDLED (6)
#define GREENLED (8)
#define BLUELED (7)


// These are the pins connected to the Wiegand D0 and D1 signals.
// Ensure your board supports external Interruptions on these pins
#define PIN_D0 2
#define PIN_D1 3




//////////////////////////////////////////////////////////////
/////////////////////////// GLOBAL VARS //////////////////////

// setup pin array
uint8_t passcode[MAXCODESIZE];
int currentDigit;

// used to manage when the last time the wiegand bus was checked
unsigned long lastKeyPress; // used to calculate timeout of keypresses
unsigned long lastInteruptCheck; // used to determine if interupts need to be checked

// settings button handlers
int settingsButtonEvent;
ButtonHandler settingsButtonHandler(PIN_SETTINGS);
unsigned long settingsModeStart; // used to ensure the duration of the settings mode
boolean settingsMode; // true if settingsMode is on, false otherwise


// used for storing the keys
KeyMemory key_storage;

// The object that handles the wiegand protocol
Wiegand wiegand;


// used for flashing LEDS
unsigned long lastLedFlash; 
boolean ledOn;



/////////////////////////////////////////////////////////
/////////////////////////// SETUP  //////////////////////
// Initialize Wiegand reader
void setup() {
  Serial.begin(9600);

  //Install listeners and initialize Wiegand reader
  wiegand.onReceive(receivedData, "Card read: ");
  wiegand.onReceiveError(receivedDataError, "Card read error: ");
  wiegand.onStateChange(stateChanged, "State changed: ");
  wiegand.begin(Wiegand::LENGTH_ANY, true);

  //initialize pins as INPUT and attaches interruptions
  pinMode(PIN_D0, INPUT);
  pinMode(PIN_D1, INPUT);
  attachInterrupt(digitalPinToInterrupt(PIN_D0), pinStateChanged, CHANGE);
  attachInterrupt(digitalPinToInterrupt(PIN_D1), pinStateChanged, CHANGE);

  //Sends the initial pin state to the Wiegand library
  pinStateChanged();

  // setup input for settings button
  pinMode(PIN_SETTINGS, INPUT_PULLUP);

  // set passcode to -1 for empty
  clearPasscode();

  // set to 0 to ensure we check on first loop
  lastInteruptCheck = 0;

  // set to 0 to ensure we check on first loop
  lastLedFlash = 0;

  // settings mode is 0 by default
  settingsMode = false;
}



////////////////////////////////////////////////////////
/////////////////////////// LOOP  //////////////////////
// Every few milliseconds, check for pending messages on the wiegand reader
// This executes with interruptions disabled, since the Wiegand library is not thread-safe
void loop() {

  // check interrupts every 100ms
  checkWiegandInterrupts();
  
  // check if last keypress is more than 5 seconds
  if(millis() - lastKeyPress >= 4950 && currentDigit > 0)
  {
    clearPasscode();
    Serial.println("beep beep beep");
  }


  // button checking
  settingsButtonEvent = settingsButtonHandler.handle();
  if(settingsButtonEvent != EV_NONE)
  {
    if (settingsButtonEvent == EV_LONGPRESS && !settingsMode)
    {
      Serial.println("Entering Add Keycode Mode");
      settingsMode = true;
      settingsModeStart = millis() + 15000;

      digitalWrite(GREENLED,HIGH);
      ledOn = true;

      
    } else if (settingsButtonEvent == EV_SHORTPRESS) {
      
      //testing stuff here
      // read the eeprom values
      Serial.print("EEPROM Size");
      Serial.println(EEPROM.length());

      key_storage.dumpEeprom();

      Serial.print("Key count: ");
      Serial.println(key_storage.keyCount());
      // each digit typed into the 
      // memory management:
        // 0 = number of pins stored
      // no matter what, we should store 8 digits of pins


      for(int i = 0; i < key_storage.keyCount(); i++)
      {
        key_storage.readKey(i);
        
        Serial.print("key from memory: ");
        for(int i = 0; i < sizeof(key_storage.key); i++)
        {
          Serial.print(key_storage.key[i]);
          Serial.print(",");
        }

        Serial.println();
      }
      
      
    }
  }

  if(settingsMode)
  {
    flashLed(GREENLED);

    if(millis() > settingsModeStart)
    {
      Serial.println("Exiting Add Keycode Mode");

      digitalWrite(GREENLED,LOW);
      ledOn = false;
      settingsMode = false;
    }
  }

}





////////////////////////////////////////////////////////
///////////////////////// METHODS //////////////////////
void checkWiegandInterrupts()
{
  if(millis() - lastInteruptCheck > 100) {
    noInterrupts();
    wiegand.flush();
    interrupts();

    lastInteruptCheck = millis();
  }

}

void clearPasscode()
{
  Serial.println("Clearing passcode");
  for(int i = 0; i < MAXCODESIZE; i++)
  {
    passcode[i] = 255;
  }
  currentDigit = 0;
}

void printLnPasscode()
{
  Serial.print("passcode");
  for(int i = 0; i < MAXCODESIZE; i++)
  {
    Serial.print(passcode[i]);
    Serial.print(",");
  }  
  Serial.println();
}


// When any of the pins have changed, update the state of the wiegand library
void pinStateChanged() {
  wiegand.setPin0State(digitalRead(PIN_D0));
  wiegand.setPin1State(digitalRead(PIN_D1));
}

// Notifies when a reader has been connected or disconnected.
// Instead of a message, the seconds parameter can be anything you want -- Whatever you specify on `wiegand.onStateChange()`
void stateChanged(bool plugged, const char* message) {
  Serial.print(message);
  Serial.println(plugged ? "CONNECTED" : "DISCONNECTED");
}

// Notifies when a card was read.
// Instead of a message, the seconds parameter can be anything you want -- Whatever you specify on `wiegand.onReceive()`
void receivedData(uint8_t* data, uint8_t bits, const char* message) {

  lastKeyPress = millis(); // used to clear the passcode if timeout

  uint8_t bytes = (bits + 7) / 8;

  // for each byte - put the int into the passcode array
  for (int i = 0; i < bytes; i++) {

    // if we come across input 11 from the keypad, then
    // we have to assume the passcode is done, and we 
    // check if it's real or not
    if(data[i] == 11 || currentDigit >= MAXCODESIZE)
    {
      // TODO
      // check if code is valid
      printLnPasscode();

      // if settings mode - then save the code to memory
      // else 
        //we're not in settings mode, check if the code is in memory
        // allow access
      if(settingsMode)
      {
        add_key_to_eeprom(passcode);
      } else {
        
      }

      
      // then we clear passcode
      clearPasscode();
    } else {
      passcode[currentDigit++] = data[i];
    }
  }

  
  printLnPasscode();
}

// Notifies when an invalid transmission is detected
void receivedDataError(Wiegand::DataError error, uint8_t* rawData, uint8_t rawBits, const char* message) {
  Serial.print(message);
  Serial.print(Wiegand::DataErrorStr(error));
  Serial.print(" - Raw data: ");
  Serial.print(rawBits);
  Serial.print("bits / ");

  //Print value in HEX
  uint8_t bytes = (rawBits + 7) / 8;
  for (int i = 0; i < bytes; i++) {
    Serial.print(rawData[i] >> 4, 16);
    Serial.print(rawData[i] & 0xF, 16);
  }
  Serial.println();
}





void flashLed(int pin)
{
  if(millis() - lastLedFlash > 500) {
    if(ledOn)
    {
      //Serial.println("Turn OFF LED");
      digitalWrite(pin,LOW);
      ledOn = false;
    } else {
      //Serial.println("Turn ON LED");
      digitalWrite(pin,HIGH);
      ledOn = true;
    }
    lastLedFlash = millis();
  }  
}



void add_key_to_eeprom(uint8_t uid[]){
  //uint8_t uid[] = { 0, 0, 0, 0, 0, 0, 0 };  // Buffer to store the returned UID
  //uint8_t uidLength;                        // Length of the UID (4 or 7 bytes depending on ISO14443A card type)
  //nfc.readCardData(&uid[0], &uidLength);
  //print_card_info(uid, uidLength);
  
  //if(key_storage.isKeyPresent(uid) || compare_keys(uid, master_key)){
  if(key_storage.isKeyPresent(uid)){
    //key already here
    Serial.println("Card already present");
  }
  else{
    Serial.println("adding new card");
    key_storage.addKey(uid);
    //delay(500);
    //beep(750);
  }
  //nfc.setCardToReadMode(PN532_MIFARE_ISO14443A);
}




boolean compareKeys(uint8_t key1[], uint8_t key2[]){
  for (int i=0; i < MAXCODESIZE; i++ ){
    if (key1[i] != key2[i]){
      return 0;
    }
  }
  return 1;
}
